//Connected modules:
const int LedRG = 13;                       //Pin commanding Red and Green Led
const int LDR = 14;                         //Pin receiving LDR value

//Tram info:
  /*Header info*/
const int headerID_Length PROGMEM= 4;
const int headerID[headerID_Length] = {'D','D','A','P'};

/* -== First Trame ==- */
  /*Header info*/
const int headerLength_1st_Trame = 2;
const int header_1st_Trame[headerLength_1st_Trame] = {'%','&'};
  
  /*Footer info*/
const int footerLength_1st_Trame = 3;
const int footer_1st_Trame[footerLength_1st_Trame] = {'@',':','@'};

/* -== Second Trame ==- */
  /*Header info*/
const int headerLength_2nd_Trame = 2;
const int header_2nd_Trame[headerLength_2nd_Trame] = {'&','%'};

  /*Footer info*/
const int footerLength_2nd_Trame = 3;
const int footer_2nd_Trame[footerLength_2nd_Trame] = {':','@',':'};

/*--------------------------------------------------------------------------------*/
/*================================================================================*/
/*--------------------------------------------------------------------------------*/

/* -==  My stack structure to stock the Trame it receives  ==- */


//Might be better to put it in a .h file. As arduino sometimes compiles functions before structures.

typedef struct ElementTrameStructure{
  unsigned int Byte;
  struct ElementTrameStructure * next = NULL;
}ElementTrame;

// ElementTrame doesn't work well on tinkercad. So when using tinkercad, replace ElementTrame by struct ElementTrameStructure

/* Function to create the structure which will stock the Trame */

ElementTrame* init_tram(){
  ElementTrame* element_trame = (ElementTrame*)malloc(sizeof(ElementTrame));
  if(element_trame == NULL){
    exit(EXIT_FAILURE);
  }
  element_trame->Byte = 0;
  element_trame->next = NULL;
  return element_trame;
}

/* Function to remove the first element of the Trame list */

void pop(ElementTrame ** top_trame){
  ElementTrame * next_element_trame = NULL;
  if(top_trame == NULL){
    exit(EXIT_FAILURE);
  }
  next_element_trame = (*top_trame)->next;
  free(*top_trame);
  *top_trame = next_element_trame;
  return;
}

/* Function to add elemenent to Trame list */

void pileup(ElementTrame ** top_trame, int incomingByte){
  ElementTrame* new_element_trame;
  new_element_trame = (ElementTrame*)malloc(sizeof(ElementTrame));
  if(new_element_trame == NULL){
    exit(EXIT_FAILURE);
  }
  new_element_trame->Byte = incomingByte;
  new_element_trame->next = *top_trame;
  *top_trame = new_element_trame;
  return;
}

void delete_trame(ElementTrame * top_trame){
  while(top_trame->next != NULL){ //Erases the trame_checked
    pop(&top_trame);
  }
}

/*--------------------------------------------------------------------------------*/
/*================================================================================*/
/*--------------------------------------------------------------------------------*/

/* -==  Receiving a Trame / Getting the info  ==- */

int print_received_byte(int incoming_byte){
  Serial.print("Receiving Byte : ");
  Serial.println(incoming_byte,HEX);
}

/* function that receives the message */

int receive_trame_info(){
  int response;   // 0: Time out / 1: Header error / 2: Footer error / 3: Error in the received Trame / 4: The info isn't recognised by our software 
  int i = 0;      // 5: info - Manual / 6: info - Automatic / 7: info - Nack / 8: info - Ack 
  int incoming_byte = -1;
  int trame_type = -1; // 1: 1st trame type / 2: 2nd trame type
  //It waits to receive the start of what could be one of two trame. If it doesn't well it times out.
  while((incoming_byte != header_1st_Trame[0] && incoming_byte != header_2nd_Trame[0]) && i<1000){
    incoming_byte = Serial.read();
    i++;
  }
  print_received_byte(incoming_byte);
  if(incoming_byte == header_1st_Trame[0]){
      trame_type = 1;
      Serial.println("The byte is similar to the header of our 1st header type.");
      freeRAM();
  }else if(incoming_byte == header_2nd_Trame[0]){
      trame_type = 2;
      Serial.println("The byte is similar to the header of our 2nd header type.");
      freeRAM();
  }
  if(trame_type != -1){ //Checks if it didn't timeout + if it didn't define a trame type
    if(trame_type == 1){ //Checks the header of the trame
      Serial.println("Checks the header of 1st Trame.");
      freeRAM();
      response = receive_X_trame(headerLength_1st_Trame, header_1st_Trame);
    }else{
      Serial.println("Checks the header of 2nd Trame.");
      freeRAM();
      response = receive_X_trame(headerLength_2nd_Trame, header_2nd_Trame);
    }
    if( response == -1 ){ //Continues to analyse the trame if there is no header error
      Serial.println("No header Error.");
      freeRAM();
      ElementTrame * trame_reception = init_tram(); //Stocks the received element in a linked structure
      if(trame_type == 1)//Checks the footer of the trame and piles up the rest of the trame
      {
        response = pileup_X_tram_and_analyse_footer(trame_reception, footer_1st_Trame, footerLength_1st_Trame);
      }else{
        response = pileup_X_tram_and_analyse_footer(trame_reception, footer_2nd_Trame, footerLength_2nd_Trame);
      }
      if(response == -1){ //Continues to analyse the trame if there is no response error
        Serial.println("It now analyse the body of the trame");
        freeRAM();
        if(trame_type == 1)//Checks the footer of the trame and piles up the rest of the trame
        {
          Serial.println("Analyse 1st trame");
          response = analyse_1st_trame(trame_reception);
        }else{
          Serial.println("Analyse 2nd trame");
          response = analyse_2nd_trame(trame_reception);
        }
      }
    }
  }else{
    response = 0; // Time out
    Serial.println("Time out");
  }
  return response;
}

int receive_X_trame(const int headerLength,const int * header){
  int res = -1;
  int incoming_byte = 0;
  int i = 0;
  Serial.println("Checks the rest of the start of the Header type.");
  for(i=1;(i<headerLength && res != 1);i++){
    incoming_byte = Serial.read();
    print_received_byte(incoming_byte);
    if(header[i] != incoming_byte){
      res = 1; //means there is a header error
      Serial.println("Error in header.");
    }
  }
  if(res != 1){
    //checks the ID of the head
    Serial.println("Checks the ID of header");
    for(i=0;(i<headerID_Length && res != 1);i++){
      incoming_byte = Serial.read();
      print_received_byte(incoming_byte);
      if(headerID[i] != incoming_byte){
        res = 1; //means there is a header error
        Serial.println("Error in header's ID.");
      }
    }
  }
  return res;
}

int pileup_X_tram_and_analyse_footer(ElementTrame* trame, const int * footer, const int footerLength){
  Serial.println("Receives the rest of the Trame and checks for the footer.");
  int res = -1;
  int incoming_byte;
  int i;
  while((Serial.available() > 0) && (res == -1)){
    incoming_byte = Serial.read();
    pileup(&trame,incoming_byte);
    print_received_byte(incoming_byte);
    if(incoming_byte == footer[0]){ //Checks for bytes similar to the start of our footer's type
      Serial.println("This byte is similar to the start of our footer's starting byte.");
      for(i=1;(i<footerLength);i++){ //Checks the next 'footerLength' bytes, and compares them to the footer
        incoming_byte = Serial.read();
        pileup(&trame,incoming_byte);
        print_received_byte(incoming_byte);
        if((footer[i] == incoming_byte) && (i == (footerLength-1))){
          res = 1; //If the footer has 0 errors it changes out of it's NULL State
        }
      }
    }
  }
  if(res==-1){
    res=2;
    Serial.println("The footer has an error.");
  } //Footer error
  if(res==1){
    res=-1; 
    Serial.println("The footer is correct.");
  }//No error it continues
  return res;
}

int analyse_1st_trame(ElementTrame * trame_reception){
  int i;
  for(i=0;i<footerLength_1st_Trame;i++){
    pop(&trame_reception);
  } //Removes footer
  int res;
  unsigned int x_MSB, x_LSB;
  int number_of_1_bit_expected, bit_value;
  int counted_1_bit = 0;
  x_LSB = trame_reception->Byte;
  pop(&trame_reception);
  x_MSB = trame_reception->Byte;
  pop(&trame_reception);
  number_of_1_bit_expected = bit_sift_combine(x_MSB, x_LSB);
  ElementTrame * trame_checked = init_tram();
  while(trame_reception->next != NULL){
    for(i=0;i<8;i++){ //Goes through the 8 bit of 1 byte and adds up the number of counted '1' bit
      bit_value = bitRead(trame_reception->Byte,(1));
      if(bit_value == 1){
        counted_1_bit = counted_1_bit + 1;
      }
    }
    pileup(&trame_checked,trame_reception->Byte);
    pop(&trame_reception);
  }
  if(number_of_1_bit_expected == counted_1_bit){ //If the number of 1 bit concords, then the message is most likely undammaged
  /* *reminder*

      - Format of the expected Tram -

      Start: %&DDAP*[0x7F7F]+0+00$[Somme des bits a 1 des champs du corps]@:@
      Manual: %&DDAP*[0xFAFA]+[0xAA]+00$[Somme des bits a 1 des champs du corps]@:@
      Automatic: %&DDAP*[0xFAFA]+[0xDD]+00$[Somme des bits a 1 des champs du corps]@:@
      Lux: %&DDAP*[0xFAFA]+0+[Lux Value]$[Somme des bits a 1 des champs du corps]@:@
      
      However we do not care about the Lux and Start message, as we are the one to send it.
      So we only care about the 0xAA and 0xDD. Which tells us if we're in manual or automatic mode

      So we only analyse a small part of the Tram

  */
    for(i=0;i<3;i++){
      pop(&trame_checked);
    }
    if(trame_checked->Byte == 0XAA){
      res = 5; // info - Manual
    }else if(trame_checked->Byte == 0XDD){
      res = 6; // info - Automatic
    }else{
      res = 4; //The information is unrecognised
    }
  }else{
    res = 3; //The Tram's body is damaged
  }
  delete_trame(trame_checked);
  return res;
}

int bit_sift_combine( unsigned int x_MSB, unsigned int x_LSB)
{
  int combined;
  combined = x_MSB;              //send x_high to rightmost 8 bits
  combined = combined<<8;        //shift x_high over to leftmost 8 bits
  combined |= x_LSB;             //logical OR keeps x_high intact in combined and fills in                                                             //rightmost 8 bits
  return combined;               //Credits: Matthew - http://projectsfromtech.blogspot.com/2013/09/combine-2-bytes-into-int-on-arduino.html
}

int analyse_2nd_trame(ElementTrame * trame_reception){
  int i = 0;
  for(i=0;i<footerLength_1st_Trame;i++){
    pop(&trame_reception);
  } //Removes footer
  int res;
  int expected_length = 1;
  int real_length = 0;
  ElementTrame * trame_checked = init_tram();
  Serial.print("Expected length of the trame_reception's body : ");
  Serial.println(expected_length);
  //It checks that the trame isn't longer than expected
  while(trame_reception->next != NULL){
    expected_length++;
    pileup(&trame_checked,trame_reception->Byte);
    pop(&trame_reception);
  }
  Serial.print("Actual length : ");
  Serial.println(real_length);
  if(real_length == expected_length){
    Serial.println("The body isn't damaged.");
    res = trame_checked->Byte;
    if((res == '!') || (res == 21)){
      res = 8; //info: Ack
    }else{
      if(res == '?'){
        res = 7; //info: Nack
      }else{
          res = 4; //The info isn't recognised by our software
      }
    }
  }else{
    Serial.println("The body is damaged.");
    res = 3; //The Tram's body is damaged
  }
  delete_trame(trame_checked);
  return res;
}

/* functions that communicates the type of info it received */

void received_information_from_Trame(int Information){
  // 0: Time out / 1: Header error / 2: Footer error / 3: Error in the received Trame / 4: The info isn't recognised by our software
  // 5: info - Manual / 6: info - Automatic / 7: info - Nack / 8: info - Ack
  if(Information == 0){
    Serial.print("Received Trame information: Time out");
  }else{
    if(Information == 1){
      Serial.print("Received Trame information: Header error");
    }else{
      if(Information == 2){
        Serial.print("Received Trame information: Footer error");
      }else{
        if(Information == 3){
          Serial.print("Received Trame information: Error in the received Trame");
        }else{
          if(Information == 4){
            Serial.print("Received Trame information: The info isn't recognised by our software");
          }else{
            if(Information == 5){
              Serial.print("Received Trame information: info - Manual");
            }else{
              if(Information == 6){
                Serial.print("Received Trame information: info - Nack");
              }else{
                if(Information == 7){
                  Serial.print("Received Trame information: info - Automatic");
                }else{
                  if(Information == 8){
                    Serial.print("Received Trame information: info - Ack");
                  }else{
                    Serial.print("Received Trame information: UNKNOWN"); 
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  Serial.print(" - ");
  Serial.println(Information);
}

/*--------------------------------------------------------------------------------*/

/* -==  Receiving a Trame / Getting the info  ==- */

void SendTrame(ElementTrame* Trame){
  Serial.print("Sending trame : ");
  while(Trame->next != NULL){
    //This is the only usefull serial print !!
    Serial.print(Trame->Byte);
    Serial.print(" ");
    pop(&Trame);
  }
  Serial.println("");
  pop(&Trame);
}

ElementTrame* form_trame(ElementTrame * body, int * footer_X_Trame, int footerLength_X_Trame, int * header_X_Trame, int headerLength_X_Trame){
  ElementTrame* trame = init_tram();
  int i;
  //add foot of Trame:
  for(i=0;i<footerLength_X_Trame;i++){
    pileup(&trame,footer_X_Trame[footerLength_X_Trame-1-i]);
  }
  //add body
  while(body->next != NULL){
    pileup(&trame,body->Byte);
    pop(&body);
  }
  //add foot
  for(i=0;i<headerLength_X_Trame-1;i++){
    pileup(&trame,header_X_Trame[headerLength_X_Trame-i-1]);
  }
  return trame;
}

/*--------------------------------------------------------------------------------*/
int GetLux(){
  return 0;
};

/*--------------------------------------------------------------------------------*/

int TramReception(int info){
  Serial.println("Waiting to get an information other than common errors.");
  //Waiting to get an information other than common errors.
  info = receive_trame_info();
  received_information_from_Trame(info);
  if(info < 5){
    //SendTrame(FormTrame(bodyNack,bodyNacklength));
    delay(1000);
    info = TramReception(info);
  }else{delay(1000);}
  return info;
}

/* Checks if it's not in Manuel mode */

void ManualTest(int Information){
  while(Information < 6){
    digitalWrite(LedRG,LOW);
    Serial.println("Checking if out of manuel mode: ");
    //turn led red
    //check Reception
    Information = receive_trame_info();
    received_information_from_Trame(Information);
    delay(1000);
  }
  digitalWrite(LedRG,HIGH);
}

/*--------------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------------
    2 type of trams:
      1st type:
      
          Start: %&DDAP*[0x7F7F]+0+00$[Somme des bits a 1 des champs du corps]@:@
          Manuel: %&DDAP*[0xFAFA]+[0xAA]+00$[Somme des bits a 1 des champs du corps]@:@
          Automatique: %&DDAP*[0xFAFA]+[0xDD]+00$[Somme des bits a 1 des champs du corps]@:@
          Lux: %&DDAP*[0xFAFA]+0+[Lux Value]$[Somme des bits a 1 des champs du corps]@:@
          
      2nd type:
          acknowledge the reception
        
          Ack:  &%DDAP!:@:
          Nack: &%DDAP?:@:

    other quick test:

      header error: %&DAAP*#$13@:@
      footer error: %&DDAP*#$13
      damaged tram: %&DDAP*asdavhsdfg€$13@:@
      wrong info:   %&DDAP*#$13@:@

    Progress:
      -ReceivedInfoFromTrame(receive_message());
              Works perfectly -> Stack structure and Receiving a Trame / Getting the info are working
      -SendTrame and FormTrame works perfectly with the pop function error removed
      -
          


----------------------------------------------------------------------------------*/
/*--------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------*/

/* -==  Setup  ==- */

void setup() {
  //setup code, runs once :
  Serial.begin(9600);
  pinMode(LedRG, OUTPUT);
  freeRAM();
  Serial.println("Starting Software :");
  /*int i;
  for(i=10;i>0;i--){
    if(i%2==1){
      digitalWrite(LedRG,HIGH);
    }else{
      digitalWrite(LedRG,LOW);
    }
    delay(1000);
    Serial.print(i);
    Serial.print(", ");
  }
  delay(1000);
  Serial.println(i);
  Serial.println("Starting the loop():");
  ReceivedTrameInformation = receive_trame();*/
}

/*--------------------------------------------------------------------------------*/

void blink_Yas(){
  digitalWrite(LedRG, HIGH);   // turn the LED on (HIGH is the voltage level)
  delay(1000);                       // wait for a second
  digitalWrite(LedRG, LOW);    // turn the LED off by making the voltage LOW
  delay(1000);       
}

/* Code to check memory usage - credit : Mikael Patel */
void freeRAM() {
  extern int __heap_start, *__brkval;
  int v;
  Serial.print("Free memory is: ");
  Serial.println((int) &v - (__brkval == 0 ? (int) &__heap_start : (int) __brkval));
}
/* ------------------------------------------------- */

  
void loop() {
  int information_received = 0;
  information_received = receive_trame_info();
  received_information_from_Trame(information_received);
  delay(1000);  
  /*
  // main code, runs repeatedly :
  // 0: Time out / 1: Header error / 2: Footer error / 3: Error in the received Trame / 4: The info isn't recognised by our software / 5: info - Manual / 6: info - Nack / 7: info - Ack
  int i;
  //Loop to send Lux value, while the information received isn't Ack.
  digitalWrite(LedRG,HIGH);
  do{
    if(ReceivedTrameInformation==5){ManualTest(ReceivedTrameInformation);}
    LuxValue = GetLux();
    bodyLux[1] = 'V';
    bodyLux[2] = 'V';
    Serial.println("Sending lux Value: ");
    //SendTrame(FormTrame(bodyLux,bodyLuxlength));
    delay(1000);
    ReceivedTrameInformation = TramReception(ReceivedTrameInformation);
  }while(ReceivedTrameInformation != 7);
  Serial.println("Message was received.");
  //waits 15sec before starting over
  for(i=0;(i<15)&&(ReceivedTrameInformation!=5);i++){
    delay(1000);
    ReceivedTrameInformation = receive_trame();
  }
  Serial.println("15 seconds are over");*/
}
