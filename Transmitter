int LedRG = 13;                       //Pin commanding Red and Green Led
int LDR = 14;                         //Pin receiving LDR value
int ReceivedTrameInformation;         //The information our receive_message() extracts
int HeaderLength = 6;
int FooterLength = 3;
int header[6] = {'%','&','D','D','A','P'};
int footer[3] = {'@',':','@'};

/*--------------------------------------------------------------------------------*/

/* -==  My stack structure to stock the Trame it receives  ==- */

//Might be better to put it in a .h file. As arduino sometimes compiles functions before structures.

typedef struct ElementTrameStructure{
  int Byte;
  struct ElementTrameStructure * next = NULL;
}ElementTrame;

/* Function to create the structure which will stock the Trame */

ElementTrame* init_tram(){
  ElementTrame* elementtrame = (ElementTrame*)malloc(sizeof(ElementTrame));
  if(elementtrame == NULL){
    exit(EXIT_FAILURE);
  }
  elementtrame->Byte = 0;
  elementtrame->next = NULL;
  return elementtrame;
}

/* Function to remove the first element of the Trame list */

void pop(ElementTrame ** toptrame){
  ElementTrame * nextElementTrame = NULL;
  if(toptrame == NULL){
    exit(EXIT_FAILURE);
  }
  nextElementTrame = (*toptrame)->next;
  free(toptrame);
  *toptrame = nextElementTrame;
  return;
}

/* Function to add elemenent to Trame list */
void pileup(ElementTrame ** toptrame, int incomingByte){
  ElementTrame* newElementTrame;
  newElementTrame = (ElementTrame*)malloc(sizeof(ElementTrame));
  
  newElementTrame->Byte = incomingByte;
  newElementTrame->next = *toptrame;
  *toptrame = newElementTrame;
  return;
}

/*--------------------------------------------------------------------------------*/

/* -==  Setup  ==- */

void setup() {
  //setup code, runs once :
  Serial.begin(9600);
}

/*--------------------------------------------------------------------------------*/

/* -==  Receiving a Trame / Getting the info  ==- */

/* function that receives the message */

int receive_message(){
  int error = 0;
  int response; // 0: Time out / 1: Header error / 2: Footer error / 3: Error in the received Trame / 4: The info isn't recognised by our software / 5: info - Manual / 6: info - Nack / 7: info - Ack 
  int i = 0;
  int incomingByte = 0;
  //It waits to receive the start of the Trames
  while(incomingByte != header[0] && i<1000){
    incomingByte = Serial.read();
    i++;
  }
  //Checks if it didn't timeout
  Serial.print("Received Byte: ");
  Serial.println(incomingByte);
  if(i<1000){
    //Checks the 'HeaderLength' first element of the beginning of the trame
    for(i=0;i<HeaderLength-1;i++){
      incomingByte = Serial.read();
      Serial.print("Received Byte: ");
      Serial.println(incomingByte);
      if(incomingByte != header[1+i]){
        error = 1; //error from header
      }
    }
    //If i != we can check the rest of the trame
    if( error == 0 ){
      ElementTrame* TrameReception = init_tram();
      while((Serial.available() > 0) && (error == 0)){
        incomingByte = Serial.read();
        Serial.print("Received Byte: ");
        pileup(&TrameReception,incomingByte);
        Serial.println(TrameReception->Byte);
        if(incomingByte == footer[0]){
          for(i=1;(i<FooterLength);i++){
            incomingByte = Serial.read();
            Serial.print("Received Byte: ");
            pileup(&TrameReception,incomingByte);
            Serial.println(TrameReception->Byte);
            if(footer[i] == incomingByte){
              if(i == (FooterLength-1)){error = 1;}
            }
          }
        }
      }
      if(error == 1){
        for(i=0;i<3;i++){
          pop(&TrameReception);
        }
        response = AnalyseTrame(TrameReception);
      }else{
        response = 2; // Footer error
      }  
    }else{
      response = 1; // Header error
    }
  }else{
    response = 0; // Time out
  }
  return response;
}

/* function to extract the trame info / check it */

int AnalyseTrame(ElementTrame* Trame){
  int rep;
  int info = 0;
  int ExpectedLength;
  int Length = 0;
  ElementTrame* TrameChecked = init_tram();
  //the 2 last Byte tells us the expected length of the Tram body length in byte
  ExpectedLength = (Trame->Byte) - 48;
  pop(&Trame);
  ExpectedLength = ((Trame->Byte) - 48) * 10 + ExpectedLength;
  pop(&Trame);
  ExpectedLength = ExpectedLength - HeaderLength - FooterLength + 1 - 2;
  Serial.print("Expected Length of the Trame's body : ");
  Serial.println(ExpectedLength);
  //It first checks if it received the full trame, by checking the lenght accordingly to the bit of control. And it put the first received byte at the top of the stack.
  while(Trame->next != NULL){
    Length++;
    pileup(&TrameChecked,Trame->Byte);
    pop(&Trame);
  }
  Serial.print("Actual length : ");
  Serial.println(Length);
  if(Length == ExpectedLength){
    //Extracts one Byte. the possible info that can be received, can be stored in one Byte. We could have made a list of the info received, which are seperated by '+' between each other
    pop(&TrameChecked); //Removes the * Byte
    info = TrameChecked->Byte;
    Serial.println(info);
    if((info == '!') || (info == 21)){
      rep = 7; //info: Ack
    }else{
      if(info == '?'){
        rep = 6; //info: Nack
      }else{
        if((info == '#') || (info == 23)){
          rep = 5; //info: Manual
        }else{
          rep = 4; //The info isn't recognised by our software
        }
      }
    }
  }else{
    rep = 3; //The Tram has missing info
  }
  return rep;
}

void send_message(char message){
  
}

void send_value(float value){
  
}
/*--------------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------------
    Expected TRAM:
      So you can test on your SERIAL without the other board:
        
          Ack:  %&DDAP*!$13@:@
          Nack: %&DDAP*?$13@:@
          Man:  %&DDAP*â‚¬$13@:@


----------------------------------------------------------------------------------*/
/*--------------------------------------------------------------------------------*/


void loop() {
  // main code, runs repeatedly :
  // 0: Time out / 1: Header error / 2: Footer error / 3: Error in the received Trame / 4: The info isn't recognised by our software / 5: info - Manual / 6: info - Nack / 7: info - Ack
  ReceivedTrameInformation = receive_message();
  if(ReceivedTrameInformation == 0){
    Serial.println("ReceivedTrameInformation: Time out");
  }else{
    if(ReceivedTrameInformation == 1){
      Serial.println("ReceivedTrameInformation: Header error");
    }else{
      if(ReceivedTrameInformation == 2){
        Serial.println("ReceivedTrameInformation: Footer error");
      }else{
        if(ReceivedTrameInformation == 3){
          Serial.println("ReceivedTrameInformation: Error in the received Trame");
        }else{
          if(ReceivedTrameInformation == 4){
            Serial.println("ReceivedTrameInformation: The info isn't recognised by our software");
          }else{
            if(ReceivedTrameInformation == 5){
              Serial.println("ReceivedTrameInformation: info - Manual");
            }else{
              if(ReceivedTrameInformation == 6){
                Serial.println("ReceivedTrameInformation: info - Nack");
              }else{
                if(ReceivedTrameInformation == 7){
                  Serial.println("ReceivedTrameInformation: info - Ack");
                }else{
                  Serial.println("ReceivedTrameInformation: UNKNOWN");
                }
              }
            }
          }
        }
      }
    }
  }
  delay(1000);
  return;
}
