#include <Arduino.h> //Had to include the Arduino.h library, or else we couldn't define or detect or pointers in the NULL State.

//Connected modules:
const int LedRG = 13;                       //Pin commanding Red and Green Led
const int LDR = 14;                         //Pin receiving LDR value

//Tram info:
/*Header info*/
const int headerID_Length PROGMEM = 4;
const int headerID[headerID_Length] = {'D', 'D', 'A', 'P'};

/* -== First Trame ==- */
/*Header info*/
const int headerLength_1st_Trame = 2;
const int header_1st_Trame[headerLength_1st_Trame] = {'%', '&'};

/*Footer info*/
const int footerLength_1st_Trame = 3;
const int footer_1st_Trame[footerLength_1st_Trame] = {'@', ':', '@'};

/* -== Second Trame ==- */
/*Header info*/
const int headerLength_2nd_Trame = 2;
const int header_2nd_Trame[headerLength_2nd_Trame] = {'&', '%'};

/*Footer info*/
const int footerLength_2nd_Trame = 3;
const int footer_2nd_Trame[footerLength_2nd_Trame] = {':', '@', ':'};

/*--------------------------------------------------------------------------------*/
/*================================================================================*/
/*--------------------------------------------------------------------------------*/

/* -==  My stack structure to stock the Trame it receives  ==- */


//Might be better to put it in a .h file. As arduino sometimes compiles functions before structures.

typedef struct ElementTrameStructure {
  int Byte;
  struct ElementTrameStructure * next = NULL;
} ElementTrame;

// ElementTrame doesn't work well on tinkercad. So when using tinkercad, replace ElementTrame by struct ElementTrameStructure

/* Function to create the structure which will stock the Trame */

ElementTrame* init_tram() {
  ElementTrame* element_trame = (ElementTrame*)malloc(sizeof(ElementTrame));
  if (element_trame == NULL) {
    exit(EXIT_FAILURE);
  }
  element_trame->Byte = 0x00;
  element_trame->next = NULL;
  return element_trame;
}

/* Function to remove the first element of the Trame list */

void pop(ElementTrame ** top_trame) {
  ElementTrame * next_element_trame = NULL;
  if (top_trame == NULL) {
    exit(EXIT_FAILURE);
  }
  next_element_trame = (*top_trame)->next;
  free(*top_trame);
  *top_trame = next_element_trame;
  return;
}

/* Function to add elemenent to Trame list */

void pileup(ElementTrame ** top_trame, int incomingByte) {
  ElementTrame* new_element_trame;
  new_element_trame = (ElementTrame*)malloc(sizeof(ElementTrame));
  if (new_element_trame == NULL) {
    exit(EXIT_FAILURE);
  }
  new_element_trame->Byte = incomingByte;
  new_element_trame->next = *top_trame;
  *top_trame = new_element_trame;
  return;
}

void delete_trame(ElementTrame * top_trame) {
  while (top_trame->next != NULL) { //Erases the trame_checked
    pop(&top_trame);
  }
  pop(&top_trame);
}

void show_trame_but_delete_it(ElementTrame * top_trame) { //For debugging. Managed to see that Arduino couldn't detect the NULL pointer without it's library.
  Serial.print("The Tram:");
  while(top_trame->next != NULL){ //Erases the trame_checked
    print_received_byte(top_trame->Byte);
    pop(&top_trame);
  }
  pop(&top_trame);
  Serial.print(" done");
}

/*--------------------------------------------------------------------------------*/
/*================================================================================*/
/*--------------------------------------------------------------------------------*/

/* -==  Receiving a Trame / Getting the info  ==- */

int print_received_byte(int incoming_byte) {
  Serial.print(incoming_byte, HEX);
  Serial.print(" ");
}

/* function that receives the message */

int receive_trame_info() {
  int response;   // 0: Time out / 1: Header error / 2: Footer error / 3: Error in the received Trame / 4: The info isn't recognised by our software
  int i = 0;      // 5: info - Manual / 6: info - Automatic / 7: info - Nack / 8: info - Ack
  int incoming_byte = -1;
  int trame_type = -1; // 1: 1st trame type / 2: 2nd trame type
  //It waits to receive the start of what could be one of two trame. If it doesn't well it times out.
  while ((incoming_byte != header_1st_Trame[0] && incoming_byte != header_2nd_Trame[0]) && i < 1000) {
    incoming_byte = Serial.read();
    i++;
  }
  Serial.print("Receiving Bytes : ");
  print_received_byte(incoming_byte);
  //freeRAM();
  if (incoming_byte == header_1st_Trame[0]) {
    trame_type = 1;
    //Serial.println("The byte is similar to the header of our 1st header type.");
  } else if (incoming_byte == header_2nd_Trame[0]) {
    trame_type = 2;
    //Serial.println("The byte is similar to the header of our 2nd header type.");
  }
  if(trame_type != -1){ //Checks if it didn't timeout + if it didn't define a trame type
    //freeRAM();
    if(trame_type == 1){ //Checks the header of the trame
      //Serial.println("Checks the header of 1st Trame.");
      response = receive_X_trame(headerLength_1st_Trame, header_1st_Trame);
    }else{
      //Serial.println("Checks the header of 2nd Trame.");
      response = receive_X_trame(headerLength_2nd_Trame, header_2nd_Trame);
    }
    if(response == -1){ //Continues to analyse the trame if there is no header error
      //Serial.println("No header Error.");
      //freeRAM();
      if (trame_type == 1){ //Checks the footer of the trame and piles up the rest of the trame
        response = pileup_X_tram_and_analyse_footer(footer_1st_Trame, footerLength_1st_Trame, trame_type);
      }else{
        response = pileup_X_tram_and_analyse_footer(footer_2nd_Trame, footerLength_2nd_Trame, trame_type);
      }
      //Use to call the analyse_1st_trame() and analyse_2nd_trame() functions. However there was a problem, that the change brought to the Tram declared in this variable wouldn't be changed by the other called functions.
    }
  }else{
    response = 0; // Time out
  }
  return response;
}

int receive_X_trame(const int headerLength, const int * header) {
  int res = -1;
  int incoming_byte = 0;
  int i = 0;
  //Serial.println("Checks the rest of the start of the Header type.");
  for (i = 1; (i < headerLength && res != 1); i++) {
    incoming_byte = Serial.read();
    print_received_byte(incoming_byte);
    if (header[i] != incoming_byte) {
      res = 1; //means there is a header error
      //Serial.println("Error in header.");
    }
  }
  if (res != 1) {
    //Serial.println("Checks the ID of header");
    for (i = 0; (i < headerID_Length && res != 1); i++) {
      incoming_byte = Serial.read();
      print_received_byte(incoming_byte);
      if (headerID[i] != incoming_byte) {
        res = 1; //means there is a header error
        //Serial.println("Error in header's ID.");
      }
    }
  }
  return res;
}


int pileup_X_tram_and_analyse_footer(const int * footer, const int footerLength, int trame_type) {
  //Serial.println("Receives the rest of the Trame and checks for the footer.");
  ElementTrame * trame = init_tram(); //Stocks the received element in a linked structure
  int res = -1;
  int incoming_byte;
  int i;
  /*Serial.print("The footer's expected bytes in HEX value: ");
  for (i = 0; i < 3; i++) {
    Serial.println(footer[i], HEX);
    Serial.print(" ");
  }*/
  while ((Serial.available() > 0) && (res == -1)) {
    incoming_byte = Serial.read();
    pileup(&trame, incoming_byte);
    print_received_byte(trame->Byte);
    if (incoming_byte == footer[0]) { //Checks for bytes similar to the start of our footer's type
      //Serial.println("This byte is similar to the start of our footer's starting byte.");
      for (i = 1; (i < footerLength); i++) { //Checks the next 'footerLength' bytes, and compares them to the footer
        incoming_byte = Serial.read();
        pileup(&trame, incoming_byte);
        print_received_byte(trame->Byte);
        if ((footer[i] == trame->Byte) && (i == (footerLength - 1))) {
          res = 1; //If the footer has 0 errors it changes out of it's NULL State
          //Serial.print("Received footer with no Error");
        }
      }
    }
  }
  if (res == -1){
    res = 2;
    //Serial.println("The footer has an error.");
    delete_trame(trame); //free's the trame collected info, as we won't use it, since it's damage.
  }//Footer error
  if(res == 1){
    //Serial.println("The footer is correct.");
    if (trame_type == 1){
      //Serial.println("Analyse 1st trame");
      res = analyse_1st_trame(trame);
    }else{
      //Serial.println("Analyse 2nd trame");
      res = analyse_2nd_trame(trame);
    }
  }
  return res;
}

int analyse_1st_trame(ElementTrame * trame_reception) {
  int i;
  for (i = 0; i < footerLength_1st_Trame; i++) {
    pop(&trame_reception);
  } //Removes footer
  int res;
  unsigned int x_MSB, x_LSB;
  int number_of_1_bit_expected, bit_value;
  int counted_1_bit = 0;
  x_LSB = trame_reception->Byte;
  pop(&trame_reception);
  x_MSB = trame_reception->Byte;
  pop(&trame_reception);
  number_of_1_bit_expected = bit_sift_combine(x_MSB, x_LSB);
  ElementTrame * trame_checked = init_tram();
  while (trame_reception->next != NULL) {
    for (i = 0; i < 8; i++) { //Goes through the 8 bit of 1 byte and adds up the number of counted '1' bit
      bit_value = bitRead(trame_reception->Byte, (1));
      if (bit_value == 1) {
        counted_1_bit = counted_1_bit + 1;
      }
    }
    pileup(&trame_checked, trame_reception->Byte);
    pop(&trame_reception);
  }
  if (number_of_1_bit_expected == counted_1_bit) { //If the number of 1 bit concords, then the message is most likely undammaged
    /* *reminder*

        - Format of the expected Tram -

        Start: %&DDAP*[0x7F7F]+0+00$[Somme des bits a 1 des champs du corps]@:@
        Manual: %&DDAP*[0xFAFA]+[0xAA]+00$[Somme des bits a 1 des champs du corps]@:@
        Automatic: %&DDAP*[0xFAFA]+[0xDD]+00$[Somme des bits a 1 des champs du corps]@:@
        Lux: %&DDAP*[0xFAFA]+0+[Lux Value]$[Somme des bits a 1 des champs du corps]@:@

        However we do not care about the Lux and Start message, as we are the one to send it.
        So we only care about the 0xAA and 0xDD. Which tells us if we're in manual or automatic mode

        So we only analyse a small part of the Tram

    */
    for (i = 0; i < 3; i++) {
      pop(&trame_checked);
    }
    if (trame_checked->Byte == 0xAA) {
      res = 5; // info - Manual
    } else if (trame_checked->Byte == 0xDD) {
      res = 6; // info - Automatic
    } else {
      res = 4; //The information is unrecognised
    }
  } else {
    res = 3; //The Tram's body is damaged
  }
  delete_trame(trame_checked);
  return res;
}

int bit_sift_combine( unsigned int x_MSB, unsigned int x_LSB)
{
  int combined;
  combined = x_MSB;              //send x_high to rightmost 8 bits
  combined = combined << 8;      //shift x_high over to leftmost 8 bits
  combined |= x_LSB;             //logical OR keeps x_high intact in combined and fills in                                                             //rightmost 8 bits
  return combined;               //Credits: Matthew - http://projectsfromtech.blogspot.com/2013/09/combine-2-bytes-into-int-on-arduino.html
}

int analyse_2nd_trame(ElementTrame * trame) {
  int i = 0;
  for (i = 0; i < footerLength_1st_Trame; i++) {
    //print_received_byte(trame->Byte); //Used to see what we had in our linked list
    pop(&trame);
  } //Removes footer
  int res = -1;
  int info;
  int expected_length = 1;
  int real_length = 0;
  ElementTrame * trame_checked = init_tram();
  //Serial.print("Expected length of the trame_reception's body : ");
  //Serial.println(expected_length);
  //It checks that the trame isn't longer than expected
  while (trame->next != NULL) {
    real_length++;
    print_received_byte(trame->Byte);
    pileup(&trame_checked, trame->Byte);
    pop(&trame);
  }
  //Serial.print("Actual length : ");
  //Serial.println(real_length);
  if(real_length == expected_length){
    //Serial.println("The body isn't damaged.");
    info = trame_checked->Byte;
    if ((info == '!') || (info == 0x00)) {
      res = 8; //info: Ack
    }else{
      if((info == '?') || (info == 0x3F)){
        res = 7; //info: Nack
      }else{
        res = 4; //The info isn't recognised by our software
      }
    }
  }else{
    //Serial.println("The body is damaged.");
    res = 3; //The Tram's body is damaged
  }
  delete_trame(trame_checked);
  delete_trame(trame);
  return res;
}

/* functions that communicates the type of info it received */

void received_information_from_Trame(int Information) {
  // 0: Time out / 1: Header error / 2: Footer error / 3: Error in the received Trame / 4: The info isn't recognised by our software
  // 5: info - Manual / 6: info - Automatic / 7: info - Nack / 8: info - Ack
  Serial.print("Received Trame information: ");
  if (Information == 0) {
    Serial.print("Time out");
  } else {
    if (Information == 1) {
      Serial.print("Header error");
    } else {
      if (Information == 2) {
        Serial.print("Footer error");
      } else {
        if (Information == 3) {
          Serial.print("Error in the received Trame");
        } else {
          if (Information == 4) {
            Serial.print("The info isn't recognised by our software");
          } else {
            if (Information == 5) {
              Serial.print("Manual");
            } else {
              if (Information == 6) {
                Serial.print("Automatic");
              } else {
                if (Information == 7) {
                  Serial.print("Nack");
                } else {
                  if (Information == 8) {
                    Serial.print("Ack");
                  } else {
                    Serial.print("UNKNOWN");
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  Serial.print(" - ");
  Serial.println(Information);
}

/*--------------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------------
    2 type of trams:
      1st type:

          Start: %&DDAP*[0x7F7F]+0+00$[Somme des bits a 1 des champs du corps]@:@
          Manuel: %&DDAP*[0xFAFA]+[0xAA]+00$[Somme des bits a 1 des champs du corps]@:@
          Automatique: %&DDAP*[0xFAFA]+[0xDD]+00$[Somme des bits a 1 des champs du corps]@:@
          Lux: %&DDAP*[0xFAFA]+0+[Lux Value]$[Somme des bits a 1 des champs du corps]@:@

      2nd type:
          acknowledge the reception

          Ack:  &%DDAP!:@:
          Nack: &%DDAP?:@:

    other quick test:

      header error: %&DAAP*#$13@:@
      footer error: %&DDAP*#$13
      damaged tram: %&DDAP*asdavhsdfg€$13@:@
      wrong info:   %&DDAP*#$13@:@

  ----------------------------------------------------------------------------------*/
/*--------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------*/

/* -==  Setup  ==- */

void setup() {
  //setup code, runs once :
  Serial.begin(115200);
  pinMode(LedRG, OUTPUT);
  freeRAM();
  Serial.println("Starting Software :");
}

/*--------------------------------------------------------------------------------*/

void blink_Yas() {
  digitalWrite(LedRG, HIGH);   // turn the LED on (HIGH is the voltage level)
  delay(1000);                       // wait for a second
  digitalWrite(LedRG, LOW);    // turn the LED off by making the voltage LOW
  delay(1000);
}

/* Code to check memory usage - credit : Mikael Patel */
void freeRAM() {
  extern int __heap_start, *__brkval;
  int v;
  Serial.print("Free memory is: ");
  Serial.println((int) &v - (__brkval == 0 ? (int) &__heap_start : (int) __brkval));
}
/* ------------------------------------------------- */


void loop() {
  int information_received = 0;
  information_received = receive_trame_info();
  received_information_from_Trame(information_received);
  delay(1000);
}
