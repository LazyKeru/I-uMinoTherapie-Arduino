int LedRG = 13;   //Pin commanding Red and Green Led
int LDR = 14;     //Pin receiving LDR value
int TrameExpectedLength = 20;

/*--------------------------------------------------------------------------------*/

/* -==  My stack structure to stock the Trame it receives  ==- */

//Might be better to put it in a .h file. As arduino sometimes compiles functions before structures.
typedef struct ElementTrameStructure ElementTrame;
struct ElementTrameStructure{
  int Byte;
  ElementTrame* suivant = NULL;
};

/* Function to create the structure which will stock the Trame */

ElementTrame* init_tram(){
  ElementTrame* elementtrame = malloc(sizeof(*elementtrame));
  if(elementtrame == NULL){
    exit(EXIT_FAILURE);
  }
  elementtrame->suivant = NULL;
  elementtrame->Byte = '%';
  return elementtrame;
}

/* Function to remove the first element of the Trame list */

void pop(ElementTrame * toptrame){
  
  if(toptrame == NULL){
    exit(EXIT_FAILURE);
  }
  ElementTrame * TrameDelete;
  TrameDelete = toptrame;
  toptrame = toptrame->suivant;
  free(TrameDelete);
}

/* Function to add elemenent to Trame list */
void pileup(ElementTrame * toptrame, int incomingByte){
  ElementTrame * newElementTrame = malloc(sizeof(*newElementTrame ));
  if(newElementTrame == NULL){
    exit(EXIT_FAILURE);
  }
  newElementTrame->Byte = incomingByte;
  newElementTrame->suivant = toptrame;
  toptrame = newElementTrame;
}

/*--------------------------------------------------------------------------------*/

/* -==  Setup  ==- */

void setup() {
  //setup code, runs once :
  Serial.begin(9600);
}

/*--------------------------------------------------------------------------------*/

/* -==  Receiving a Trame / Getting the info  ==- */

/* function that receives the message */

int receive_message(){
  int TrameLength = 1;
  int response; // 0: Time out / 1: Trame too long
  int i = 0;
  int incomingByte = NULL;
  //It waits to receive the start of the Trames
  while(incomingByte != '%' && i<1000){
    incomingByte = Serial.read();
    i++;
  }
  //Checks if it didn't timeout
  if(i<1000){
    ElementTrame* TrameReception = init_tram();
    i = 0;
    while(Serial.available() > 0 && i!=1){
      incomingByte = Serial.read();
      //Checks if it received the end of a trame. Incase another trame is sent right after, or else we would get a huge stack of multiple trames
      if(incomingByte == '@'){
        incomingByte = Serial.read();
        if(incomingByte == ':'){
          if(incomingByte == '@'){
            pileup(TrameReception,'@');
            pileup(TrameReception,':');
            pileup(TrameReception,'@');
          }else{
            pileup(TrameReception,'@');
            pileup(TrameReception,':');
            pileup(TrameReception,incomingByte);
          }
          TrameLength = TrameLength + 3;
        }else{
          pileup(TrameReception,'@');
          pileup(TrameReception,incomingByte);
          TrameLength = TrameLength + 2;
        }
      }else{
        pileup(TrameReception,incomingByte);
        TrameLength++;
      }
      //End of our checkup
    }
    //Checks if the lenght of the Trame is the one we want
    if(TrameLength == TrameExpectedLength){
      response = AnalyseTrame(TrameReception);
    }else{
      response = 1; // Trame too long
    }
  }else{
    response = 0; // Time out
  }
  return response;
}

/* function to extract the trame info / check it */

int AnalyseTrame(ElementTrame* Trame){
  
}
